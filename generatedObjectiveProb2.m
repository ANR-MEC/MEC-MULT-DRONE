function [obj, grad] = generatedObjectiveProb2(inputVariables, extraParams)
%generatedObjectiveProb2 Compute objective function value and gradient
%
%   OBJ = generatedObjectiveProb2(INPUTVARIABLES, EXTRAPARAMS) computes
%   the objective value OBJ at the point INPUTVARIABLES, using the extra
%   parameters in EXTRAPARAMS.
%
%   [OBJ, GRAD] = generatedObjectiveProb2(INPUTVARIABLES, EXTRAPARAMS)
%   additionally computes the objective gradient value GRAD at the current
%   point.
%
%   Auto-generated by prob2struct on 01-Aug-2024 11:06:45

import optim.problemdef.gradients.sum.*;


%% Variable indices.
fidx = 1:320;
gidx = 321:1600;
lidx = 1601:2816;
midx = 2817:3136;
pidx = 3137:4416;

%% Map solver-based variables to problem-based.
f = reshape(inputVariables(fidx), [16, 20]);
g = reshape(inputVariables(gidx), [4, 16, 20]);
l = reshape(inputVariables(lidx), [4, 16, 19]);
m = reshape(inputVariables(midx), [1, 16, 20]);
p = reshape(inputVariables(pidx), [4, 16, 20]);


%% Compute objective function.
arg72 = extraParams{1};
arg74 = extraParams{2};
arg76 = extraParams{3};
arg77 = extraParams{4};
arg79 = extraParams{5};
arg73 = f.^3;
arg75 = (p .* arg74);
arg78 = g.^3;
arg80 = sum((arg77 .* arg78), 'all');
obj = ((sum((arg72 .* arg73), 'all') + sum((arg75 .* arg76), 'all')) + (arg79 .* arg80));

if nargout > 1
    %% Compute objective gradient.
    % To call the gradient code, notify the solver by setting the
    % SpecifyObjectiveGradient option to true.
    arg86 = zeros(4416, 1);
    fjac = sparse(320, 1);
    pjac = sparse(1280, 1);
    gjac = sparse(1280, 1);
    arg81 = 1;
    arg82 = (SumJacobian([4 16 20], [1 2 3]) * (arg81.*arg79(:)));
    gjac = gjac + ((arg82.*arg77(:)).*(3.*g(:).^2));
    arg83 = (SumJacobian([4 16 20], [1 2 3]) * arg81);
    arg84 = (arg83.*arg76(:));
    pjac = pjac + (arg84.*arg74(:));
    arg85 = (SumJacobian([16 20], [1 2]) * arg81);
    fjac = fjac + ((arg85.*arg72(:)).*(3.*f(:).^2));
    arg86(fidx,:) = fjac;
    arg86(pidx,:) = pjac;
    arg86(gidx,:) = gjac;
    grad = arg86(:);
end
end